Description: Enable support for Mali EGL 
 Make mutter work with Mali Wayland binary.
 .
 mutter (3.27.92-1) experimental; urgency=medium
 .
   * New upstream release candidate (LP: #1752123, LP: #1718238)
   * Bump minimum wayland-protocols to 1.12
   * Drop bump-api.patch: Applied in new release
Author: Jeremy Bicha <jbicha@debian.org>
Bug-Ubuntu: https://bugs.launchpad.net/bugs/1718238
Bug-Ubuntu: https://bugs.launchpad.net/bugs/1752123

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2018-03-15

--- mutter-3.27.92.orig/cogl/cogl/driver/gl/cogl-framebuffer-gl.c
+++ mutter-3.27.92/cogl/cogl/driver/gl/cogl-framebuffer-gl.c
@@ -1417,7 +1417,7 @@ _cogl_framebuffer_gl_read_pixels_into_bi
                                                             &gl_intformat,
                                                             &gl_format,
                                                             &gl_type);
-#if HAVE_COGL_GL
+#ifdef HAVE_COGL_GL
   /* As we are reading pixels, we want to consider the bitmap according to
    * its real pixel format, not the swizzled channels we pretend face to the
    * pipeline.
--- mutter-3.27.92.orig/cogl/cogl/winsys/cogl-winsys-egl-x11.c
+++ mutter-3.27.92/cogl/cogl/winsys/cogl-winsys-egl-x11.c
@@ -268,29 +268,12 @@ _cogl_winsys_egl_get_display (void *nati
   EGLDisplay dpy = NULL;
   const char *client_exts = eglQueryString (NULL, EGL_EXTENSIONS);
 
-  if (g_strstr_len (client_exts, -1, "EGL_KHR_platform_base"))
-    {
-      PFNEGLGETPLATFORMDISPLAYEXTPROC get_platform_display =
-	(void *) eglGetProcAddress ("eglGetPlatformDisplay");
-
-      if (get_platform_display)
-	dpy = get_platform_display (EGL_PLATFORM_X11_KHR, native, NULL);
-
-      if (dpy)
-	return dpy;
-    }
-
-  if (g_strstr_len (client_exts, -1, "EGL_EXT_platform_base"))
-    {
-      PFNEGLGETPLATFORMDISPLAYEXTPROC get_platform_display =
-	(void *) eglGetProcAddress ("eglGetPlatformDisplayEXT");
-
-      if (get_platform_display)
-	dpy = get_platform_display (EGL_PLATFORM_X11_KHR, native, NULL);
-
-      if (dpy)
-	return dpy;
-    }
+  PFNEGLGETPLATFORMDISPLAYEXTPROC get_platform_display =
+        (void *) eglGetProcAddress ("eglGetPlatformDisplayEXT");
+  if (get_platform_display)
+       dpy = get_platform_display (EGL_PLATFORM_GBM_KHR, native, NULL);
+  if (dpy)
+       return dpy;
 
   return eglGetDisplay ((EGLNativeDisplayType) native);
 }
--- mutter-3.27.92.orig/cogl/cogl/winsys/cogl-winsys-glx-private.h
+++ mutter-3.27.92/cogl/cogl/winsys/cogl-winsys-glx-private.h
@@ -31,7 +31,9 @@
 #ifndef __COGL_WINSYS_GLX_PRIVATE_H
 #define __COGL_WINSYS_GLX_PRIVATE_H
 
+#ifdef COGL_HAS_GLX_SUPPORT
 const CoglWinsysVtable *
 _cogl_winsys_glx_get_vtable (void);
+#endif
 
 #endif /* __COGL_WINSYS_GLX_PRIVATE_H */
--- mutter-3.27.92.orig/src/backends/native/meta-cursor-renderer-native.c
+++ mutter-3.27.92/src/backends/native/meta-cursor-renderer-native.c
@@ -587,7 +587,7 @@ should_have_hw_cursor (MetaCursorRendere
   if (!can_draw_cursor_unscaled (renderer, cursor_sprite))
     return FALSE;
 
-  return TRUE;
+  return FALSE;
 }
 
 static gboolean
--- mutter-3.27.92.orig/src/backends/native/meta-renderer-native-gles3.c
+++ mutter-3.27.92/src/backends/native/meta-renderer-native-gles3.c
@@ -207,8 +207,10 @@ meta_renderer_native_gles3_blit_shared_b
 
   width = gbm_bo_get_width (shared_bo);
   height = gbm_bo_get_height (shared_bo);
+  strides[0] = gbm_bo_get_stride (shared_bo);
   format = gbm_bo_get_format (shared_bo);
 
+  /*
   n_planes = gbm_bo_get_plane_count (shared_bo);
   for (i = 0; i < n_planes; i++)
     {
@@ -216,6 +218,7 @@ meta_renderer_native_gles3_blit_shared_b
       offsets[i] = gbm_bo_get_offset (shared_bo, i);
       modifiers[i] = gbm_bo_get_modifier (shared_bo);
     }
+  */
 
   egl_image = create_egl_image (egl,
                                 egl_display,
--- mutter-3.27.92.orig/src/backends/native/meta-renderer-native.c
+++ mutter-3.27.92/src/backends/native/meta-renderer-native.c
@@ -1592,25 +1592,28 @@ gbm_get_next_fb_id (MetaGpuKms         *
   uint32_t handles[4] = { 0, };
   uint32_t strides[4] = { 0, };
   uint32_t offsets[4] = { 0, };
-  uint64_t modifiers[4] = { 0, };
+  //uint64_t modifiers[4] = { 0, };
   int i;
 
   /* Now we need to set the CRTC to whatever is the front buffer */
   next_bo = gbm_surface_lock_front_buffer (gbm_surface);
 
-  for (i = 0; i < gbm_bo_get_plane_count (next_bo); i++)
+  /*for (i = 0; i < gbm_bo_get_plane_count (next_bo); i++)
     {
       strides[i] = gbm_bo_get_stride_for_plane (next_bo, i);
       handles[i] = gbm_bo_get_handle_for_plane (next_bo, i).u32;
       offsets[i] = gbm_bo_get_offset (next_bo, i);
       modifiers[i] = gbm_bo_get_modifier (next_bo);
     }
+    */
+   strides[0] = gbm_bo_get_stride (next_bo);
+   handles[0] = gbm_bo_get_handle (next_bo).u32;
 
   kms_fd = meta_gpu_kms_get_fd (gpu_kms);
 
-  if (modifiers[0] != DRM_FORMAT_MOD_INVALID)
+  if (0) //modifiers[0] != DRM_FORMAT_MOD_INVALID)
     {
-      if (drmModeAddFB2WithModifiers (kms_fd,
+      /*if (drmModeAddFB2WithModifiers (kms_fd,
                                       gbm_bo_get_width (next_bo),
                                       gbm_bo_get_height (next_bo),
                                       gbm_bo_get_format (next_bo),
@@ -1624,7 +1627,7 @@ gbm_get_next_fb_id (MetaGpuKms         *
           g_warning ("Failed to create new back buffer handle: %m");
           gbm_surface_release_buffer (gbm_surface, next_bo);
           return FALSE;
-        }
+        }*/
     }
   else if (drmModeAddFB2 (kms_fd,
                           gbm_bo_get_width (next_bo),
@@ -2006,16 +2009,16 @@ meta_renderer_native_create_surface_gbm
     meta_renderer_native_get_gpu_data (renderer_native,
                                        onscreen_native->render_gpu);
 
-  modifiers = get_supported_modifiers (onscreen, format);
+  //modifiers = get_supported_modifiers (onscreen, format);
 
-  if (modifiers)
+  if (0) //modifiers)
     {
-      new_gbm_surface =
+      /*new_gbm_surface =
         gbm_surface_create_with_modifiers (renderer_gpu_data->gbm.device,
                                            width, height, format,
                                            (uint64_t *) modifiers->data,
                                            modifiers->len);
-      g_array_free (modifiers, TRUE);
+      g_array_free (modifiers, TRUE);*/
     }
   else
     {
@@ -3068,12 +3071,21 @@ create_renderer_gpu_data_gbm (MetaRender
                                                gbm_device, NULL, error);
   if (egl_display == EGL_NO_DISPLAY)
     {
+  g_set_error (error, G_IO_ERROR,
+               G_IO_ERROR_FAILED,
+               "meta_egl_get_platform_display error"
+  );
       gbm_device_destroy (gbm_device);
       return NULL;
     }
 
-  if (!meta_egl_initialize (egl, egl_display, error))
+  if (!meta_egl_initialize (egl, egl_display, error)) {
+  g_set_error (error, G_IO_ERROR,
+               G_IO_ERROR_FAILED,
+               "meta_egl_initialize error"
+  );
     return NULL;
+  }
 
   renderer_gpu_data = meta_create_renderer_native_gpu_data (gpu_kms);
   renderer_gpu_data->renderer_native = renderer_native;
--- mutter-3.27.92.orig/src/backends/x11/meta-renderer-x11.c
+++ mutter-3.27.92/src/backends/x11/meta-renderer-x11.c
@@ -55,7 +55,9 @@ get_x11_cogl_winsys_vtable (CoglRenderer
       return _cogl_winsys_egl_xlib_get_vtable ();
     case COGL_DRIVER_GL:
     case COGL_DRIVER_GL3:
+ #ifdef COGL_HAS_GLX_SUPPORT
       return _cogl_winsys_glx_get_vtable ();
+ #endif
     case COGL_DRIVER_ANY:
     case COGL_DRIVER_NOP:
     case COGL_DRIVER_WEBGL:
