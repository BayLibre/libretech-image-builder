diff --git a/cogl/cogl/winsys/cogl-winsys-egl-x11.c b/cogl/cogl/winsys/cogl-winsys-egl-x11.c
index c1d01dccd..cff84692a 100644
--- a/cogl/cogl/winsys/cogl-winsys-egl-x11.c
+++ b/cogl/cogl/winsys/cogl-winsys-egl-x11.c
@@ -268,29 +268,12 @@ _cogl_winsys_egl_get_display (void *native)
   EGLDisplay dpy = NULL;
   const char *client_exts = eglQueryString (NULL, EGL_EXTENSIONS);
 
-  if (g_strstr_len (client_exts, -1, "EGL_KHR_platform_base"))
-    {
-      PFNEGLGETPLATFORMDISPLAYEXTPROC get_platform_display =
-	(void *) eglGetProcAddress ("eglGetPlatformDisplay");
-
-      if (get_platform_display)
-	dpy = get_platform_display (EGL_PLATFORM_X11_KHR, native, NULL);
-
-      if (dpy)
-	return dpy;
-    }
-
-  if (g_strstr_len (client_exts, -1, "EGL_EXT_platform_base"))
-    {
-      PFNEGLGETPLATFORMDISPLAYEXTPROC get_platform_display =
-	(void *) eglGetProcAddress ("eglGetPlatformDisplayEXT");
-
-      if (get_platform_display)
-	dpy = get_platform_display (EGL_PLATFORM_X11_KHR, native, NULL);
-
-      if (dpy)
-	return dpy;
-    }
+  PFNEGLGETPLATFORMDISPLAYEXTPROC get_platform_display =
+        (void *) eglGetProcAddress ("eglGetPlatformDisplayEXT");
+  if (get_platform_display)
+       dpy = get_platform_display (EGL_PLATFORM_GBM_KHR, native, NULL);
+  if (dpy)
+       return dpy;
 
   return eglGetDisplay ((EGLNativeDisplayType) native);
 }
diff --git a/cogl/cogl/winsys/cogl-winsys-glx-private.h b/cogl/cogl/winsys/cogl-winsys-glx-private.h
index 9fb386ff7..7d081dee7 100644
--- a/cogl/cogl/winsys/cogl-winsys-glx-private.h
+++ b/cogl/cogl/winsys/cogl-winsys-glx-private.h
@@ -31,7 +31,9 @@
 #ifndef __COGL_WINSYS_GLX_PRIVATE_H
 #define __COGL_WINSYS_GLX_PRIVATE_H
 
+#ifdef COGL_HAS_GLX_SUPPORT
 const CoglWinsysVtable *
 _cogl_winsys_glx_get_vtable (void);
+#endif
 
 #endif /* __COGL_WINSYS_GLX_PRIVATE_H */
diff --git a/src/backends/native/meta-cursor-renderer-native.c b/src/backends/native/meta-cursor-renderer-native.c
index c7326af42..26fd876f1 100644
--- a/src/backends/native/meta-cursor-renderer-native.c
+++ b/src/backends/native/meta-cursor-renderer-native.c
@@ -603,7 +603,7 @@ should_have_hw_cursor (MetaCursorRenderer *renderer,
   if (!can_draw_cursor_unscaled (renderer, cursor_sprite))
     return FALSE;
 
-  return TRUE;
+  return FALSE;
 }
 
 static gboolean
diff --git a/src/backends/native/meta-renderer-native-gles3.c b/src/backends/native/meta-renderer-native-gles3.c
index dbc59b6f6..36f34e7ff 100644
--- a/src/backends/native/meta-renderer-native-gles3.c
+++ b/src/backends/native/meta-renderer-native-gles3.c
@@ -207,8 +207,10 @@ meta_renderer_native_gles3_blit_shared_bo (MetaEgl        *egl,
 
   width = gbm_bo_get_width (shared_bo);
   height = gbm_bo_get_height (shared_bo);
+  strides[0] = gbm_bo_get_stride (shared_bo);
   format = gbm_bo_get_format (shared_bo);
 
+  /*
   n_planes = gbm_bo_get_plane_count (shared_bo);
   for (i = 0; i < n_planes; i++)
     {
@@ -216,6 +218,7 @@ meta_renderer_native_gles3_blit_shared_bo (MetaEgl        *egl,
       offsets[i] = gbm_bo_get_offset (shared_bo, i);
       modifiers[i] = gbm_bo_get_modifier (shared_bo);
     }
+  */
 
   egl_image = create_egl_image (egl,
                                 egl_display,
diff --git a/src/backends/native/meta-renderer-native.c b/src/backends/native/meta-renderer-native.c
index fc6b22302..94f18d95e 100644
--- a/src/backends/native/meta-renderer-native.c
+++ b/src/backends/native/meta-renderer-native.c
@@ -1595,7 +1595,7 @@ gbm_get_next_fb_id (MetaGpuKms         *gpu_kms,
   uint32_t handles[4] = { 0, };
   uint32_t strides[4] = { 0, };
   uint32_t offsets[4] = { 0, };
-  uint64_t modifiers[4] = { 0, };
+  //uint64_t modifiers[4] = { 0, };
   int i;
 
   /* Now we need to set the CRTC to whatever is the front buffer */
@@ -1607,20 +1607,22 @@ gbm_get_next_fb_id (MetaGpuKms         *gpu_kms,
       return FALSE;
     }
 
-  for (i = 0; i < gbm_bo_get_plane_count (next_bo); i++)
+  /*for (i = 0; i < gbm_bo_get_plane_count (next_bo); i++)
     {
       strides[i] = gbm_bo_get_stride_for_plane (next_bo, i);
       handles[i] = gbm_bo_get_handle_for_plane (next_bo, i).u32;
       offsets[i] = gbm_bo_get_offset (next_bo, i);
       modifiers[i] = gbm_bo_get_modifier (next_bo);
     }
+    */
+  strides[0] = gbm_bo_get_stride (next_bo);
+  handles[0] = gbm_bo_get_handle (next_bo).u32;
 
   kms_fd = meta_gpu_kms_get_fd (gpu_kms);
 
-  if (renderer_native->use_modifiers &&
-      modifiers[0] != DRM_FORMAT_MOD_INVALID)
+  if (0)
     {
-      if (drmModeAddFB2WithModifiers (kms_fd,
+      /*if (drmModeAddFB2WithModifiers (kms_fd,
                                       gbm_bo_get_width (next_bo),
                                       gbm_bo_get_height (next_bo),
                                       gbm_bo_get_format (next_bo),
@@ -1634,7 +1636,7 @@ gbm_get_next_fb_id (MetaGpuKms         *gpu_kms,
           g_warning ("Failed to create new back buffer handle: %m");
           gbm_surface_release_buffer (gbm_surface, next_bo);
           return FALSE;
-        }
+        }*/
     }
   else if (drmModeAddFB2 (kms_fd,
                           gbm_bo_get_width (next_bo),
@@ -2011,19 +2013,19 @@ meta_renderer_native_create_surface_gbm (CoglOnscreen        *onscreen,
     meta_renderer_native_get_gpu_data (renderer_native,
                                        onscreen_native->render_gpu);
 
-  if (renderer_native->use_modifiers)
+  /*if (renderer_native->use_modifiers)
     modifiers = get_supported_modifiers (onscreen, format);
-  else
+  else*/
     modifiers = NULL;
 
   if (modifiers)
     {
-      new_gbm_surface =
+      /*new_gbm_surface =
         gbm_surface_create_with_modifiers (renderer_gpu_data->gbm.device,
                                            width, height, format,
                                            (uint64_t *) modifiers->data,
                                            modifiers->len);
-      g_array_free (modifiers, TRUE);
+      g_array_free (modifiers, TRUE);*/
     }
 
   if (!new_gbm_surface)
@@ -3077,12 +3079,20 @@ create_renderer_gpu_data_gbm (MetaRendererNative  *renderer_native,
                                                gbm_device, NULL, error);
   if (egl_display == EGL_NO_DISPLAY)
     {
+      g_set_error (error, G_IO_ERROR,
+                   G_IO_ERROR_FAILED,
+                   "meta_egl_get_platform_display error");
       gbm_device_destroy (gbm_device);
       return NULL;
     }
 
   if (!meta_egl_initialize (egl, egl_display, error))
-    return NULL;
+    {
+      g_set_error (error, G_IO_ERROR,
+                   G_IO_ERROR_FAILED,
+                   "meta_egl_initialize error");
+      return NULL;
+    }
 
   renderer_gpu_data = meta_create_renderer_native_gpu_data (gpu_kms);
   renderer_gpu_data->renderer_native = renderer_native;
diff --git a/src/backends/x11/meta-renderer-x11.c b/src/backends/x11/meta-renderer-x11.c
index bb52d3caf..55dde6597 100644
--- a/src/backends/x11/meta-renderer-x11.c
+++ b/src/backends/x11/meta-renderer-x11.c
@@ -55,7 +55,9 @@ get_x11_cogl_winsys_vtable (CoglRenderer *renderer)
       return _cogl_winsys_egl_xlib_get_vtable ();
     case COGL_DRIVER_GL:
     case COGL_DRIVER_GL3:
+ #ifdef COGL_HAS_GLX_SUPPORT
       return _cogl_winsys_glx_get_vtable ();
+ #endif
     case COGL_DRIVER_ANY:
     case COGL_DRIVER_NOP:
     case COGL_DRIVER_WEBGL:
